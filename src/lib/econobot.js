
//Utilit√°rios

const { QrCodePix } = require("qrcode-pix"); 
const delay = require('../utils/delay');
const validPhoneNumber = require('../utils/isAPhoneNumber');
const { v4 } = require("uuid");
const qrCodeTerminal = require("qrcode-terminal");
const { toBRL } = require('../utils/toBRL');
const env = require("dotenv");
const { MessageMedia } = require("whatsapp-web.js");

env.config();

const shoppingCartService = require("../services/shoppingCartService");

//Reposit√≥rios

const shoppingCartRepository = require('../repositories/shoppingCartRepository');
const userInfosRepository = require('../repositories/userInfosRepository');
const botBusyRepository = require('../repositories/inMemory/botBusyInMemoryRepository');
const userRepository = require('../repositories/userRepository');
const productRepository = require("../repositories/productRepository");

//Reposit√≥rios em mem√≥ria

const UserInfosForm = require("./userForm");
const userFormInMemoryRepository = require('../repositories/inMemory/userFormInMemoryRepository');
const itemsListInMemoryRepository = require("../repositories/inMemory/itemsListInMemoryRepository");
const userLastSelectedItemInMemoryRepository = require("../repositories/inMemory/userLastSelectedItemInMemoryRepository");
const userLastMessageInMemoryRepository = require('../repositories/inMemory/userLastMessageInMemoryRepository');
const userStateInMemoryRepository = require("../repositories/inMemory/userStateInMemoryRepository");

const clearMemoryService = require("../services/clearMemoryService");

class Econobot {

    client

    botName

    defaultMessages

    currentNumber

    constructor({ client, botName }){

        this.botName = botName

        this.client = client;

        this.defaultMessages = {
            selectMenuOption:`*A cada etapa algumas op√ß√µes ser√£o apresentadas para voc√™, e basta voc√™ responder com o n√∫mero ou a letra da a op√ß√£o desejada*\n\nVoc√™ tamb√©m pode digitar a qualquer momento as palavras chave *"ver carrinho" para gerencia-lo* e *"finalizar atendimento" para encerrar seu atendimento.*`,
            initialMenu:'*Escolha a op√ß√£o desejada*\n1 - Fazer pedido',
            menuCheckout:"*O que deseja fazer ? digite a op√ß√£o desejada.*\n\n1 - Pesquisar novo(s) produto(s)\n2 - Deletar Produto\n3 - Alterar quantidade de produto\n4 - Limpar carrinho\n5 - Finalizar pedido",
            paymentMenu:"",

        }

        this.handleMessage = this.handleMessage.bind(this);

    }

    initialize(){
        
        this.client.on('qr',this.handleQrCode);

        this.client.on('ready',this.handleReady);

        this.client.on('message',this.handleMessage);

        this.client.initialize();

    }

    handleQrCode(qrCode){
        
        qrCodeTerminal.generate(qrCode,{
            small:true
        })

    }

    handleReady(ready){

        console.log('Econobot est√° pronto para uso !');

    }


    async sendMessageMediaMedia(mimeType,data,fileName){

        const media = new MessageMedia(mimeType,data,fileName);

        await this.say(media);

    }

    async handleMessage(message){

        try {

            this.currentNumber = message.from;

            const lowerMessage = message.body.toLowerCase();

            const userLastMessage = userLastMessageInMemoryRepository.findLastMessage(this.currentNumber);

            if( !userLastMessage ){

                userLastMessageInMemoryRepository.addLastMessage(this.currentNumber);

            }

            userLastMessageInMemoryRepository.updateLastMessage(this.currentNumber,new Date());

            const botBusy = botBusyRepository.findOne(this.currentNumber);;

            if( !botBusy ){

                botBusyRepository.add(this.currentNumber);

            }

            if( botBusy && botBusy.isBusy ){

                return

            }

            const user = await userRepository.findOne({
                id: this.currentNumber
            });

        
            if( !user ){

                const userInMemory = userFormInMemoryRepository.findOne(this.currentNumber);

                if( !userInMemory ){

                    const newInMemoryUser = new UserInfosForm(message.from,'WAITING_MESSAGE_NAME');

                    userFormInMemoryRepository.insert(newInMemoryUser);;

                    await this.say(`Ol√° ! me chamo ${this.botName} e sou o assistente virtual do ECONOCOMPRAS ! üòÅü§ñ‚úå`);
        
                    await this.say('Notei que voc√™ √© novo por aqui. Por tanto, para eu iniciar seu atendimento, pe√ßo que por gentileza me forne√ßa algumas informa√ß√µes !');
        
                    await this.say('Primeiramente, qual √© seu nome completo ? üëÄ');

                    return;


                }

        
                const handleUserRegisterSteps = {
        
                    'WAITING_MESSAGE_NAME': async () => {
        
                        if( message.body.length < 12 ){
        
                            await message.reply('Hmmm... me parece que este n√£o √© seu nome completo. Por gentileza, me envie seu nome completo para que eu possa completar seu cadastro !');
        
                            return;
        
                        }

                        
                        userInMemory.setCurrentStep("WAITING_MESSAGE_NUMBER");

                        await message.reply(`Perfeito, ${message.body}`);

                        userInMemory.setName(message.body);

                        await this.say('Agora pe√ßo me informe o seu telefone para contato üì≥');

        
                    },
        
                    'WAITING_MESSAGE_NUMBER': async () => {
        

                        if( !validPhoneNumber(message.body) ){
        
                            await message.reply('Ops ! parece que este n√∫mero de telefone √© inv√°lido. Por favor, envie um n√∫mero de telefone v√°lido');
        
                            return;
        
                        }

                        const numberExists = await userRepository.findOne({
                            numero_telefone: message.body
                        });

                        if( numberExists ){

                            await message.reply('Este n√∫mero j√° se encontra cadastrado no nosso sistema. Por gentileza, informe outro n√∫mero');

                            return

                        }

                        userInMemory.setCurrentStep("WAITING_MESSAGE_ADRESS");

                        userInMemory.setNumber(message.body);
        
                        await message.reply('Show !')
        
                        await this.say('E por √∫ltimo, mas n√£o menos importante: seu endere√ßo üì¨');

        
                    },
        
                    'WAITING_MESSAGE_ADRESS': async () => {
        
                        userInMemory.setAdress(message.body);

                        userInMemory.setCurrentStep("CHOOSE_MENU_OPTION");
        
                        const { id, nome_completo, endereco, numero_telefone, current_step } = userInMemory;

                        await userRepository.insertUser({
                            id,
                            nome_completo,
                            current_step,
                            nivel_acesso_id: 1
                        });

                        await userInfosRepository.insertInfos({
                            usuario_id: id,
                            endereco,
                            numero_telefone
                        });
                        
                        userStateInMemoryRepository.addState(user.id,"CHOOSE_MENU_OPTION");
        
                        await this.say('Perfeito ! seu cadastro est√° completo üòéüòÜ');

                        await this.say(this.defaultMessages.selectMenuOption);

                        userFormInMemoryRepository.delete(this.currentNumber);
                        
        
                    },
                    
        
                }
        
                return await handleUserRegisterSteps[userInMemory.current_step]();
        
            }

            const userState = userStateInMemoryRepository.findState(user.id);

            console.log(userState);

            if( !userState ){

                userStateInMemoryRepository.addState(user.id);

                await this.say(`Ol√°, ${user.nome_completo} ! Que bom ver voc√™ de novo por aqui üòÅ. Como posso ajudar ?`)

                await this.say(this.defaultMessages.selectMenuOption);

                await this.say(this.defaultMessages.initialMenu);

                return;


            }

            if(['v','voltar'].includes(lowerMessage)){

                const lastState = userStateInMemoryRepository.findState(user.id);

                const { state_historic } = lastState;

                //Pega o ultimo item da lista novamente

                const lastStateHistoric = state_historic[ state_historic.length - 1];

                if( lastStateHistoric === 'CHOOSE_MENU_OPTION' ){

                    await this.say('Voc√™ j√° se encontra no menu inicial üòâ');

                    return

                }

                //Se voltar, retirar o √∫ltimo registro da lista...

                state_historic.pop();

                const lastStateVerificator = {

                    "CHOOSE_MENU_OPTION": `Voc√™ voltou para a aba de menu principal.\n${this.defaultMessages.initialMenu}`,
                    "SEARCH_PRODUCT": 'Voc√™ voltou para a aba de busca de produtos.\nPor favor, busque por algum item',
                    "CHOOSE_ITEM":"Voc√™ voltou para a aba de sele√ß√£o de produtos. Por favor, selecione novamente algum produto da lista.",
                    "SELECT_PRODUCT_QUANTY":`Voc√™ voltou para a aba de sele√ß√£o de quantidade. Por favor, selecione novamente a quantidade desejada para o item ao qual voc√™ selecionou`,
                    "USER_SHOPPING_MANAGER_OPTIONS":`Voc√™ voltou para o menu checkout. ${this.defaultMessages.checkoutMenu}`,
                    "PAYMENT_OPTIONS":`Voc√™ voltou para o menu de pagamento.\n${this.defaultMessages.paymentMenu}`

                }

                userStateInMemoryRepository.updateState(user.id,lastStateHistoric);

                await this.say(lastStateVerificator[lastStateHistoric]);

                return

            }

            if(['vom','voltar ao menu'].includes(lowerMessage)){

                userStateInMemoryRepository.updateState(user.id,'CHOOSE_MENU_OPTION');

                itemsListInMemoryRepository.removeItemsList(user.id);

                await this.say('Certo, voc√™ foi redirecionado ao menu inicial üòâ');

                await this.say(this.defaultMessages.initialMenu);

                return

            }


            if(['c','ver carrinho'].includes(lowerMessage)){

                await message.reply('Aguarde enquanto busco aqui seu carrinho... √â r√°pidinho ! üòâ');

                const userShoppingCart = await shoppingCartService.calcUserTotalShoppingCart(user.id);

                if( userShoppingCart.length === 0 ){

                    await this.say('Ops... parece que no momento voc√™ n√£o tem nenhum item no seu carrinho üëÄ\n Que tal adicionar alguns itens?');

                    return

                }

                const {  productsWithCalcPerItem, totalShoppingCart } = userShoppingCart;

                userStateInMemoryRepository.updateState(user.id,"USER_SHOPPING_MANAGER_OPTIONS");

                for await( const product of productsWithCalcPerItem ){

                    await this.say(`*ID: ${product.produto_id}\nProduto: ${product.nome_produto}* *${product.quantidade}* *UND X ${toBRL(product.valor_produto)} - ${toBRL(product.total)}*`);

                }

                await this.say(`*Valor total ${toBRL(totalShoppingCart)}*`);

                await this.say(this.defaultMessages.menuCheckout);
                

                return

            }

            if(['fa','finalizar atendimento'].includes(lowerMessage)){

                userStateInMemoryRepository.updateState(user.id,null);

                clearMemoryService.clearUserLastProductAndList(user.id);
                
                await this.say(`Certo. At√© breve, ${user.nome_completo} !`)
        
                return

            
            }

            
            const handleUserState = {

                'CHOOSE_MENU_OPTION': async () => {

                    const validOptions = ['1'];

                    const handleMenuOption = {

                        '1': async () => {

                            userStateInMemoryRepository.updateState(user.id,"SEARCH_PRODUCT");

                            await this.say(`Vamos l√° ! digite o nome do produto desejado.`)

                        },

                        'default': async () => {

                            await message.reply('Op√ß√£o inv√°lida ! Por favor, selecione uma op√ß√£o v√°lida.\n1 - Fazer pedido')

                        },

                    }

                    const validOption = validOptions.find( option => option === message.body );

                    handleMenuOption[ validOption || 'default' ]();

                },

                'SEARCH_PRODUCT': async () => {

                    // Busca os produtos no banco de dados original ECONOCOMPRAS

                    const products = await productRepository.findAll({
                        codigo_barras: message.body,
                        descricao: message.body
                    });

                    //Valida tudo o que √© necess√°rio -> O item existe ? h√° estoque ?

                    if( products.length === 0 ){

                        await message.reply(`N√£o consegui encontrar o produto desejado. Tente buscar por outro nome, ou se preferir, pesquise por outro produto.`);

                        return

                    }

                    //Adiciona um novo "produto" em mem√≥ria, que na verdade pe a op√ß√ß√£o de n√£o ter encontrado o produto desejado

                    products.push({Descricao:'',precoUnitario:'',Codigo_Barra:''});

                    let productSearchList = 'Foram encontrados os seguintes items referentes a sua pesquisa.\n\n*Digite o n√∫mero da op√ß√£o correspondente ao produto*';

                    products.forEach(function(product,id){

                        const index = id+=1;

                        if( product.Descricao && product.precoUnitario ){

                            productSearchList += `\n\n*${index} - ${product.Descricao} - R$ ${product.precoUnitario}*`

                        }

                        if( id === products.length - 1){

                            productSearchList += `\n\n*V - Voltar ao Menu Inicial*`;

                        }

                    });

                    await this.say(productSearchList)

                    userStateInMemoryRepository.updateState(user.id,"CHOOSE_ITEM");

                    itemsListInMemoryRepository.addItemsToList({
                        id: user.id,
                        items: products
                    });


                },

                "CHOOSE_ITEM": async () => {

                    const lastItems = itemsListInMemoryRepository.getItemsList(user.id);

                    if( !lastItems ){

                        await this.say(`Infelizmente ocorreu um erro e n√£o consegui obter a sua √∫ltima lista de pesquisa üò¢. Por gentileza, pesquise novamente algum produto !`);

                        userRepository.setCurrentStep(user.id,"SEARCH_PRODUCT");

                        return

                    }

                    const index = Number(message.body) - 1;

                    const { items } = lastItems;

                    const product = items[index];

                    if( !product ){

                        await message.reply(`Desculpe, mas o item ${message.body} n√£o foi listado. Por favor, selecione algum dos produtos que listei acima`);

                        return

                    }

                    //Verifica se o usu√°rio j√° possui este produto no carrinho. Se sim, n√£o poder√° dar continuidade a adi√ß√£o

                    const userAlreadyHasProduct = await shoppingCartRepository.getOneItemFromShoppingCart(user.id,product.Descricao);

                    if( userAlreadyHasProduct ){

                        await this.say(`${user.nome_completo}, voc√™ j√° possui ${product.Descricao} no seu carrinho.\n\nSe deseja adicionar mais quantidades deste item, digite *carrinho* e selecione a op√ß√£o correspondente`);

                        return;

                    }

                    userStateInMemoryRepository.updateState(user.id,"SELECT_PRODUCT_QUANTY");

                    await this.say(`Qual a quantidade de "${product.Descricao}" que voc√™ gostaria de adicionar ao seu carrinho ?`);

                    userLastSelectedItemInMemoryRepository.addSelectedItem({
                        id: user.id,
                        selected_item: product
                    });


                },

                "SELECT_PRODUCT_QUANTY": async () => {

                    const quanty = Number(message.body);

                    const product = userLastSelectedItemInMemoryRepository.getSelectedItem(user.id);

                    if( !quanty ){

                        await message.reply('Ops ! parece que isso n√£o √© um n√∫mero. Por favor, informe a quantidade de itens que deseja adicionar ao seu carrinho.');

                        return

                    }

                    if( !product ){

                        userRepository.setCurrentStep(user.id,"SEARCH_PRODUCT");
                        
                        await this.say(`${user.nome_completo}, N√£o identifiquei aqui o item ao qual voc√™ est√° se referindo para adicionar esta quantidade.\n\n*Por gentileza, pesquise novamente algum produto para que eu possa prosseguir no seu atendimento !*`);

                        return

                    }

                    const { selected_item } = product;

                    await shoppingCartRepository.insertToShoppingCart({
                        usuario_id: user.id,
                        nome_produto: selected_item.Descricao,
                        valor_produto: selected_item.precoUnitario,
                        quantidade: message.body
                    });

                    userStateInMemoryRepository.updateState(user.id,"SEARCH_PRODUCT");

                    await this.say(`*Perfeito ! adicionei ${message.body}X quantidade(s) de ${selected_item.Descricao.toUpperCase()} ao seu carrinho üòâ*"`);

                    clearMemoryService.clearUserLastProductAndList(user.id);

                    await this.say(`Qual(is) o(s) pr√≥ximo(s) produto(s) que voc√™ gostaria de pesquisar?\n\n *Lembrando que voc√™ pode digitar "ver carrinho" a qualquer momento para gerenciar seu pedido üõí`);


                },

                'USER_SHOPPING_MANAGER_OPTIONS': async () => {

                    const valid = [ "1","2","3","4","5"];

                    const handleShoppingOptions = {

                        "1": async () => {

                            userStateInMemoryRepository.updateState(user.id,"SEARCH_PRODUCT");

                            clearMemoryService.clearUserLastProductAndList(user.id);

                            await this.say('Qual o produto que voc√™ gostaria de pesquisar?');


                        },

                        "2": async () => {

                            await this.say('Por gentileza, digite o ID do produto que voc√™ gostaria de remover do carrinho !');

                            const product = await shoppingCartRepository.getOneItemFromShoppingCart(user.id,message.body);

                            if( !product ){

                                await this.say('Ops... parece que este produto n√£o se encontra no seu carrinho. Por favor, digite o ID do produto que deseja remover do seu carrinho !');

                                return

                            }

                            await shoppingCartRepository.removeItemFromShoppingCart(user.id,message.body);

                            await this.say(`${user.nome_completo}, o "${product.nome_produto}" foi removido com sucesso do seu carrinho !`);

                        },

                        "3": async () => {

                            await this.say('Por gentileza, digite o ID do produto que voc√™ gostaria de alterar a quantidade');

                        },

                        "4": async () => {

                            shoppingCartRepository.removeAllItemsFromShoppingCart(user.id);

                        },

                        "5": async () => {

                            userStateInMemoryRepository.updateState(user.id,"CONFIRM_ADRESS");

                            await this.say(`Antes de continuarmos, por favor, confirme se seu endere√ßo est√° correto:\n\n*${user.endereco}*`);

                            await this.say('Voc√™ confirma este endere√ßo ?\n S - Sim\nN - N√£o');

                        },

                        "default": async () =>{

                            await this.say("Op√ß√£o inv√°lida !");

                        }

                    }

                    const option = valid.find( option => option.includes(lowerMessage) );

                    handleShoppingOptions[ option ?? 'default']();

                },

                "PAYMENT_OPTIONS": async () => {

                    const validPayment = ['1','2','3'];

                    const handlePayment = {

                        '1': async () => {


                        },

                        '2': async () => {

                        },

                        '4': async () => {
                            
                        },

                        "3": async () => {

                            const userShoppingCart = await shoppingCartService.calcUserTotalShoppingCart(user.id);

                            const {  totalShoppingCart } = userShoppingCart;

                            await this.say(`*Envie um PIX no valor de ${toBRL(totalShoppingCart)} para a seguinte chave:*`);

                            await this.say(`*${process.env.ECONOCOMPRAS_PIX_USER}*`);

                            await this.say('*√â poss√≠vel tamb√©m realizar o pagamento escaneando o qrCode abaixo:*');

                            const payload = QrCodePix({
                                version: "01",
                                key:process.env.ECONOCOMPRAS_PIX_KEY,
                                name: process.env.ECONOCOMPRAS_PIX_USER,
                                transactionId: v4().slice(25),
                                message: "ECONOCOMPRAS",
                                value: totalShoppingCart,
                            });
                    
                            const qrCode = await payload.base64();

                            const [ resourceType, base64String ] = qrCode.split(',');

                            await this.sendMessageMediaMedia('image/jpg',base64String,'image.jpg');

                            await this.say('Ap√≥s efetuar o pagamento, por gentileza envie um print do comprovante üòÅ');

                        },

                        "CONFIRM_ADRESS": async () => {

                            if( lowerMessage.includes('n') ){
                                
                                await this.say('Perfeito ! obrigado por confirmar seu endere√ßo üòç');

                                return

                            }

                        },

                        'default': async () => {

                            message.reply('Op√ß√£o de pagamento inv√°lida !');

                        }


                    }

                    const payment = validPayment.find( payment => payment === message.body);

                    handlePayment[ payment ?? 'default' ]();

                }

            }

            await handleUserState[userState.current_state]();

        }catch(err){

            console.log(err);

            this.say('Lamento. Infelizmente um erro interno ocorreu ! Tente novamente mais tarde.');

        }

    }

    async say(message,withDelay = true){

        botBusyRepository.update(this.currentNumber,true);

        if( withDelay ){

            await delay();

        }

        await this.client.sendMessage(this.currentNumber,message);

        botBusyRepository.update(this.currentNumber,false);

    }


}

module.exports.Econobot = Econobot;